#!/usr/bin/env python

import sys, socket, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last_heartbeat = [time.time()] * len(replica_ids)


# The current term
current_term = 0
# Who you are voting for
# None if there is not currently an election
# If it's non None and there's no election,
# that's the leader
voted_for = None

# The number of votes for me to be leader this
# election cycle
votes_for_me = 0
# Log of all messages
log = [None]

state_machine = {}

commit_index = 0
last_applied = 0

# True if you are currently the leader
is_leader = False

next_index = [1] * len(replica_ids)
last_match = [0] * len(replica_ids)


def send_heartbeat():
	send_append_entries([], 'FFFF')

def send_append_entries(entries, dest):
	prev_log_index = len(log) - 1
	prev_log_term = None
	if prev_log_index is not -1:
		prev_log_term = log[prev_log_index]

	msg = {
		'src': my_id,
		'dst': dest,
		'type': 'append',
		'leader': my_id,
		'term': current_term,
		'prev_log_index': prev_log_index,
		'prev_log_term': prev_log_term,
		'entries': entries,
		'leader_commit': commit_index
	}
	sock.send(json.dumps(msg))


def recieve_append_entries(leader_term, leader_id, prev_log_index, prev_log_term, entries_to_add, leader_commit):
	global log, commit_index, voted_for, current_term

	if current_term > leader_term:
		return [current_term, False]

	if log[prev_log_index] is not prev_log_term:
		return [current_term, False]


	if leader_term > current_term:
		current_term = leader_term

	# Make sure you know who the leader is
	voted_for = leader_id

	#TODO: Optimize
	index = 1
	for entry in entries_to_add:
		entry_in_local_log = None
		try:
			entry_in_local_log = log[prev_log_index + index]
		except:
			# That spot in the log is empty
			5
		# If an existing entry conflicts with a new one
		# truncate the list
		if entry_in_local_log is not entry:
			log = log[:prev_log_index + 1]

		# Append into the log
		log.append(entry)
		index += 1

	# Update our committed index
	if leader_commit > commit_index:
		commit_index =  min(leader_commit, len(log) -1)


	return [current_term, True]

# Handle the response from an append
def recieve_append_response(resp, src_id):
	global current_term, voted_for, is_leader
	# If my term is behind the response term, update mine
	# and relinquish leadership
	if resp[0] > current_term:
		current_term = resp[0]
		voted_for = None
		is_leader = False

	replica_index = replica_ids.index(src_id)

	# The append were successful!
	if resp[1]:
		next_index = len(log)
		last_match[replica_index] += 1
	# The append failed,
	# let's try again earlier
	else:
		next_index[replica_index] -= 1



def send_append_entries_response(resp):


# Starts an election from this machine
def start_election():
	global current_term, voted_for, votes_for_me, last_heartbeat
	current_term += 1
	voted_for = my_id
	votes_for_me = 1
	last_heartbeat = time.time()
	print("Election term: " + str(current_term))
	send_vote_request()


# Sends a request to all other machines to vote
# for this machine for leader
def send_vote_request():
	req = {
		'src': my_id,
		'dst': 'FFFF',
		'leader': 'FFFF',
		'type': 'election',
		'term': current_term,
		'last_log_index': len(log) - 1,
		'last_log_term': log[len(log) - 1]
	}
	sock.send(json.dumps(req))


# Handles recieving a vote for a new leader
def recieve_vote_request(candidate_term, candidate_id, last_log_index, last_log_term):
	global voted_for, current_term
	if candidate_term < current_term:
		return [current_term, False]
	else:

		print(str(my_id) + " Recieved request to vote for " + str(candidate_id))
		current_term = candidate_term
		candidate_available = voted_for == None or voted_for == candidate_id
		log_up_to_date = last_log_index >= len(log) - 1
		if candidate_available and log_up_to_date:
			voted_for = candidate_id
			print(str(my_id) + " voted for " + str(candidate_id))
			return [current_term, True]
		else:
			return [current_term, False]


# Sends a response back to the person we've
# recieved a vote request from
def send_vote_response(vote_results, destination):
	req = {
		'src': my_id,
		'dst': destination,
		'leader': 'FFFF',
		'type': 'election_vote',
		'term': vote_results[0],
		'vote_granted': vote_results[1]
	}
	sock.send(json.dumps(req))

# Recieves a vote for this election
def recieve_vote_response(term, voted_for_me):
	global votes_for_me, is_leader, voted_for
	# If the vote is for a previous term, ignore it
	if term == current_term:
		if voted_for_me:
			votes_for_me += 1

		print(str(my_id) + " got " + str(votes_for_me) + " votes")

		votes_needed = ((len(replica_ids) + 1) / 2) + 1
		# If you have enough votes, seize power
		if votes_for_me >= votes_needed:
			is_leader = True
			voted_for = None
			print("Election is over: " + str(my_id) + " is leader")
			send_heartbeat()

# Finds the highest value the majority of the replicas
# are willing to commit to
def highest_agreed_match_index():
	follower_index = 0
	match_index = 0
	while follower_index < len(replica_ids):
		test_val = last_match[follower_index]
		higher_or_equal_count = 0
		for match_val in last_match:
			if match_val >= test_val:
				higher_or_equal_count += 1

		# More than half of the replicas are ready to move
		# the commit index forward
		if higher_or_equal_count > len(replica_ids) / 2:
			match_index = max(match_index, test_val)

		follower_index += 1

	return match_index
# Main loop
while True:


	# Leader general responsibilities
	if is_leader:

		follower_index = 0
		while follower_index < len(replica_ids):
			replica_id = replica_ids[follower_index]

			time_since_last_heartbeat = time.time() - last_heartbeat[follower_index]
			time_since_in_ms = time_since_last_heartbeat * 1000

			last_log_index = len(log) - 1
			next_index_for_follower = next_index[follower_index]

			#Sends logs to followers if necesary
			if last_log_index >= next_index_for_follower:
				entries = [next_index_for_follower:]
				send_append_entries(entries, replica_id)
				last_heartbeat[follower_index] = time.time()
			else:
				# Sends heartbeat if we need it
				if time_since_in_ms > 100:
					send_append_entries([], replica_id)
					last_heartbeat[follower_index] = time.time()


		# Increments the commit index if the majority of replicas agree
		highest_match = highest_agreed_match_index()

		if highest_match > commit_index and log[highest_match][0] is current_term:
			commit_index = highest_match

	else:
		# If this follower is behind the times,
		# Apply the next log item to the state machine
		if commit_index > last_applied:
			last_applied += 1
			entry = log[last_applied]
			key = entry[1]
			val = entry[2]
			state_machine[key] = val

	if not is_leader:

		threshold = random.randint(0, 300)
		threshold += 300

		# If you are a follower, wait 150-300ms before starting
		# elections
		if threshold < time_since_in_ms:
			start_election()

	ready = select.select([sock], [], [], 0.1)[0]

	if sock in ready:
		msg_raw = sock.recv(32768)

		if len(msg_raw) == 0: continue
		msg = json.loads(msg_raw)

		if 'append' in msg['type']:
			leader_term = msg['term']
			leader_id = msg['leader']
			prev_log_index = msg['prev_log_index']
			prev_log_term = msg['prev_log_term']
			entries = msg['entries']
			leader_commit = msg['leader_commit']
			response = recieve_append_entries(leader_term, leader_id, prev_log_index, prev_log_term, entries, leader_commit)
			send_append_entries_response(response)
			last_heartbeat = time.time()

		# For now, ignore get() and put() from clients
		if msg['type'] in ['get', 'put']:

			#Redirect if a follower recieves the request
			if not is_leader:
				new_msg = {
					'src': my_id,
					'dst': msg['src'],
					'leader': voted_for,
					'type': 'redirect',
					'MID': msg['MID'],
					}
				print("Redirect to " + str(voted_for))
				sock.send(json.dumps(new_msg))

			else:
				if 'get' in msg['type']:
					key = msg['key']
					val = state_machine[key]
					ok_msg = {
						'src': my_id,
						'dst': msg['src'],
						'leader': my_id,
						'type': 'ok',
						'MID': msg['MID'],
						'value': val
						}
					sock.send(json.dumps(ok_msg))
				if 'put' in msg['type']:
					ok_msg = {
						'src': my_id,
						'dst': msg['src'],
						'leader': my_id,
						'type': 'ok',
						'MID': msg['MID']
						}
					key = msg['key']
					val = msg['value']
					# Apply to state machine
					state_machine[key] = val
					# Add to log
					log.append([current_term, key, val])
					sock.send(json.dumps(ok_msg))


		# You just got a vote request for a new leader
		if msg['type'] == 'election':
			candidate_term = msg['term']
			candidate_id = msg['src']
			last_log_index = msg['last_log_index']
			last_log_term = msg['last_log_term']
			resp = recieve_vote_request(candidate_term, candidate_id, last_log_index, last_log_term)
			send_vote_response(resp, candidate_id)

		# You just got a vote response, possibly voting for you!
		if msg['type'] == 'election_vote':
			term = msg['term']
			voted_for_me = msg['vote_granted']
			recieve_vote_response(term, voted_for_me)
